<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>fork二三事 | My Personal Space</title>
    <meta name="description" content="A personal blog and portfolio built with VitePress">
    <meta name="generator" content="VitePress v2.0.0-alpha.15">
    <link rel="preload stylesheet" href="/Garden/assets/style.CNQYn0WQ.css" as="style">
    <link rel="preload stylesheet" href="/Garden/vp-icons.css" as="style">
    
    <script type="module" src="/Garden/assets/app.CQx_ainX.js"></script>
    <link rel="preload" href="/Garden/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Garden/assets/chunks/theme.Bd7wgDxd.js">
    <link rel="modulepreload" href="/Garden/assets/chunks/framework.oG4qJsc7.js">
    <link rel="modulepreload" href="/Garden/assets/posts_fork二三事.md.BlHmVkS_.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-170c53fe><!--[--><!--]--><!--[--><span tabindex="-1" data-v-451012a8></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-451012a8>Skip to content</a><!--]--><!----><header class="VPNav" data-v-170c53fe data-v-21e98c69><div class="VPNavBar" data-v-21e98c69 data-v-edbf9404><div class="wrapper" data-v-edbf9404><div class="container" data-v-edbf9404><div class="title" data-v-edbf9404><div class="VPNavBarTitle" data-v-edbf9404 data-v-16a8c3d8><a class="title" href="/Garden/" data-v-16a8c3d8><!--[--><!--]--><!----><span data-v-16a8c3d8>My Personal Space</span><!--[--><!--]--></a></div></div><div class="content" data-v-edbf9404><div class="content-body" data-v-edbf9404><!--[--><!--]--><div class="VPNavBarSearch search" data-v-edbf9404><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-edbf9404 data-v-138a1628><span id="main-nav-aria-label" class="visually-hidden" data-v-138a1628> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Garden/" tabindex="0" data-v-138a1628 data-v-1494679c><!--[--><span data-v-1494679c>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Garden/posts.html" tabindex="0" data-v-138a1628 data-v-1494679c><!--[--><span data-v-1494679c>Blog</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Garden/about.html" tabindex="0" data-v-138a1628 data-v-1494679c><!--[--><span data-v-1494679c>About</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-edbf9404 data-v-9cde98c8><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-9cde98c8 data-v-c6d441d6 data-v-54855812><span class="check" data-v-54855812><span class="icon" data-v-54855812><!--[--><span class="vpi-sun sun" data-v-c6d441d6></span><span class="vpi-moon moon" data-v-c6d441d6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-edbf9404 data-v-a0cc7756 data-v-6e5e7bc9><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-6e5e7bc9 data-v-9015c34a><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-edbf9404 data-v-392c0efd data-v-6d4d2382><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6d4d2382><span class="vpi-more-horizontal icon" data-v-6d4d2382></span></button><div class="menu" data-v-6d4d2382><div class="VPMenu" data-v-6d4d2382 data-v-76c0c713><!----><!--[--><!--[--><!----><div class="group" data-v-392c0efd><div class="item appearance" data-v-392c0efd><p class="label" data-v-392c0efd>Appearance</p><div class="appearance-action" data-v-392c0efd><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-392c0efd data-v-c6d441d6 data-v-54855812><span class="check" data-v-54855812><span class="icon" data-v-54855812><!--[--><span class="vpi-sun sun" data-v-c6d441d6></span><span class="vpi-moon moon" data-v-c6d441d6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-392c0efd><div class="item social-links" data-v-392c0efd><div class="VPSocialLinks social-links-list" data-v-392c0efd data-v-6e5e7bc9><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-6e5e7bc9 data-v-9015c34a><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-edbf9404 data-v-6ffe035d><span class="container" data-v-6ffe035d><span class="top" data-v-6ffe035d></span><span class="middle" data-v-6ffe035d></span><span class="bottom" data-v-6ffe035d></span></span></button></div></div></div></div><div class="divider" data-v-edbf9404><div class="divider-line" data-v-edbf9404></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-170c53fe data-v-1924e3fd><div class="container" data-v-1924e3fd><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-1924e3fd data-v-85ddaa89><button data-v-85ddaa89>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-170c53fe data-v-f1c8b00b><div class="VPDoc has-aside" data-v-f1c8b00b data-v-9a3aec1d><!--[--><!--]--><div class="container" data-v-9a3aec1d><div class="aside" data-v-9a3aec1d><div class="aside-curtain" data-v-9a3aec1d></div><div class="aside-container" data-v-9a3aec1d><div class="aside-content" data-v-9a3aec1d><div class="VPDocAside" data-v-9a3aec1d data-v-21b7d62c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-21b7d62c data-v-3dd37849><div class="content" data-v-3dd37849><div class="outline-marker" data-v-3dd37849></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-3dd37849>On this page</div><ul class="VPDocOutlineItem root" data-v-3dd37849 data-v-24ee4c62><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-21b7d62c></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-9a3aec1d><div class="content-container" data-v-9a3aec1d><!--[--><!--]--><main class="main" data-v-9a3aec1d><div style="position:relative;" class="vp-doc _Garden_posts_fork%E4%BA%8C%E4%B8%89%E4%BA%8B" data-v-9a3aec1d><div><h1 id="fork-二三事" tabindex="-1">fork 二三事 <a class="header-anchor" href="#fork-二三事" aria-label="Permalink to “fork 二三事”">​</a></h1><p>笔者在自己学习fork的时候产生了好几个疑惑，经过笔者的冥思苦想和资料查阅，把我觉得初学者比较难理解的点总结讲解一下。</p><h2 id="unix-v6pp如何实现的父子进程fork的返回值不同" tabindex="-1">unix v6pp如何实现的父子进程fork的返回值不同 <a class="header-anchor" href="#unix-v6pp如何实现的父子进程fork的返回值不同" aria-label="Permalink to “unix v6pp如何实现的父子进程fork的返回值不同”">​</a></h2><p>在学校的操作系统讲到fork之前我就已经学习csapp的异常控制流而会使用fork进行基本的编程了(调用unix api)，知道所谓的“调用一次，返回两次”，但是却没有深入研究过具体是如何实现的。于是我和同学交流过后，我去看了mit 的xv6的实现，发现其实是在fork的系统调用里把risc-v的a0寄存器改掉了，虽然返回语句都是<code>return pid</code>，但是从汇编的角度，其实返回不同的值。到这里我以为我理解了一切，但是当我去自己看我们unxi v6pp的具体实现的时候就懵了，他的实现是和xv6的实现不同的，或者说他的实现是更贴近unix v6原作者汤普森的实现逻辑的，就是swtch的使用，虽然说看起来没有xv6好懂，但是本质是一样的，都是要从汇编的视角理解，到这里我真的难以想象汤普森是如何想出这种实现方式的，实在是天才且伟大。那么接下来就来具体讲解一下。</p><p>让我们编写用户态的程序，调用fork函数时，我们进行了一次系统调用，<code>trap</code>之后调用了<code>Sys_Fork</code>，然后在内部调用了<code>processManager</code>类的<code>Fork函数</code>，在这个函数里就到了我们的核心<code>newProc</code>函数，正如我们之前所了解的，newProc会将很大一部分父进程的东西赋值给子进程，得到了和父进程基本一样的进程图象，然后聪明的你看到以下这段代码突然顿悟：哦，原来fork是通过newProc不同的返回值实现的</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#C678DD;">	if</span><span style="color:#ABB2BF;"> ( </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#61AFEF;">NewProc</span><span style="color:#ABB2BF;">() )</span><span style="color:#7F848E;font-style:italic;">	/* 子进程返回1，父进程返回0 */</span></span>
<span class="line"><span style="color:#ABB2BF;">	{</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">		/* 子进程fork()系统调用返回0 */</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_ar0</span><span style="color:#ABB2BF;">[User::EAX] </span><span style="color:#C678DD;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_cstime</span><span style="color:#C678DD;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_stime</span><span style="color:#C678DD;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_cutime</span><span style="color:#C678DD;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_utime</span><span style="color:#C678DD;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">	}</span></span>
<span class="line"><span style="color:#C678DD;">	else</span></span>
<span class="line"><span style="color:#ABB2BF;">	{</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">		/* 父进程进程fork()系统调用返回子进程PID */</span></span>
<span class="line"><span style="color:#E5C07B;">		u</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">u_ar0</span><span style="color:#ABB2BF;">[User::EAX] </span><span style="color:#C678DD;">=</span><span style="color:#E5C07B;"> child</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">p_pid</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">	}</span></span></code></pre></div><p>然后你会怀着激动的心去看newProc的内部，期待着可以证实你的猜想，但是却惊讶的发现————<code>newProc</code>函数“看起来”是恒返回0的，那么就意味着刚才这段代码永远执行else分支，但，这对吗？这明显不对！但是为什么...这就需要我们去看具体的栈帧了。</p><p>细心的读者可能会想到，在父进程为子进程创建好进程图象时，父进程和子进程的栈帧栈顶都是newProc栈帧，父进程的相对好理解，显然初始状态是父进程上台，如果newProc正常返回就会返回0，然后Fork就会返回pid，符合我们的设想。而子进程稍复杂一点，因为初始时刻，子进程是没上台的，处于就绪状态，但是他总有一刻要上台，而上台靠的是<code>swtch</code>函数，可以理解成swtch的返回就是子进程newProc的返回，因为撤销newProc栈帧时取的都是newProc栈帧保存的old eip，就同样返回到子进程调用newProc的下一条指令，而我们知道x86体系结构函数返回值是存在EAX寄存器的，所以子进程swtch返回1就以为着将子进程的核心栈的eax寄存器的值改为1，从汇编的角度理解，newProc返回时核心栈eax的值，父进程是0，子进程是1，就表现出newProc父进程返回0，子进程返回1，根据这个判断条件就实现了processManager::Fork的父进程返回pid，子进程返回0。</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#7F848E;font-style:italic;">	/* </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	 * 被fork出的进程在上台之前会在被调度上台时返回1，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	 * 并同时返回到NewProc()执行的地址</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	 */</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span></code></pre></div><p>到这里读者可能对fork如何实现父进程返回pid，子进程返回0有了一个更好的了解，那我们再看一下从c程序角度，笔者到这里又出现了理解的问题</p><h2 id="父子进程的并发流" tabindex="-1">父子进程的并发流 <a class="header-anchor" href="#父子进程的并发流" aria-label="Permalink to “父子进程的并发流”">​</a></h2><p>假设我们在用户态写了这样一段代码</p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0" dir="ltr"><code><span class="line"><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;">(pid</span><span style="color:#C678DD;">=</span><span style="color:#61AFEF;">fork</span><span style="color:#ABB2BF;">()){</span></span>
<span class="line"><span style="color:#61AFEF;">    printf</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Parent process</span><span style="color:#56B6C2;">\n</span><span style="color:#98C379;">&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">else</span><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#61AFEF;">    printf</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Child process</span><span style="color:#56B6C2;">\n</span><span style="color:#98C379;">&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre></div><p>如果你在一个系统多次运行这个程序你会得到什么结果呢，你觉得是谁先打印，父进程还是子进程，还是不确定。其实csapp明确告诉过我们就是不确定的，但是我那时候还不知道为什么，在系统了解方钰老师讲解的unix v6pp新进程的创建全过程之后，我对他有了一个更深入的了解。</p><p>按照我们正常的对程序的理解，他默认是顺序执行的，即我们可以理解为，在fork之前，其实我们执行的是“父进程”，因为是父进程创建的子进程，也就是fork的一套流程默认是父进程先占用cpu来执行，比如父进程按流程正常从newProc一步步返回到例行调度阶段</p><p>此时不论如何父进程的优先级都大于100，而优于子进程的栈帧是复制而来，所以一步步返回也会到trap重算优先数，此时也重算完了p_pri，此时父子进程处于大致的同一优先级，在父进程即将返回用户态的时候进行例行调度，子进程有可能抢占父进程的cpu，如果发生了这个情况，一共有三种原因：</p><ol><li>父进程在cpu上执行了太长时间，在整数秒被重算优先级，发现优先数增加（优先级降低），设置RunRun标志位</li><li>父进程由于某些原因入睡，非抢占式放弃了cpu</li><li>父进程未返回用户态之前，系统恰好产生中断，cpu要响应中</li></ol></div></div></main><footer class="VPDocFooter" data-v-9a3aec1d data-v-84b12b97><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api-examples.md\":\"OLE68FN3\",\"index.md\":\"M4vyoyBW\",\"markdown-examples.md\":\"pQGPoq-4\",\"posts_fork二三事.md\":\"BlHmVkS_\",\"posts_hello-world.md\":\"DEE2D4Xl\",\"posts_index.md\":\"DvKy0S7M\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"My Personal Space\",\"description\":\"A personal blog and portfolio built with VitePress\",\"base\":\"/Garden/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Blog\",\"link\":\"/posts\"},{\"text\":\"About\",\"link\":\"/about\"}],\"sidebar\":{\"/posts/\":[],\"/\":[{\"text\":\"Recent Posts\",\"items\":[{\"text\":\"Hello World\",\"link\":\"/posts/hello-world\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>