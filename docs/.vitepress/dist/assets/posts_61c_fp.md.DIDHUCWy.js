import{_ as l,c as e,o as s,ah as o,aj as t,ak as i,al as n,am as c,an as p}from"./chunks/framework.Cby5TGbY.js";const _=JSON.parse('{"title":"CS61c Floating Point","description":"","frontmatter":{"title":"CS61c Floating Point","date":"2025-11-26T00:00:00.000Z"},"headers":[],"relativePath":"posts/61c_fp.md","filePath":"posts/61c_fp.md"}'),r={name:"posts/61c_fp.md"};function d(m,a,h,u,b,$){return s(),e("div",null,[...a[0]||(a[0]=[o('<h1 id="floating-point" tabindex="-1">Floating Point <a class="header-anchor" href="#floating-point" aria-label="Permalink to “Floating Point”">​</a></h1><h2 id="基础定点表示法" tabindex="-1">基础定点表示法 <a class="header-anchor" href="#基础定点表示法" aria-label="Permalink to “基础定点表示法”">​</a></h2><p>95% of the folks out there are completely clueless about floatingpoint.&quot; author=&quot;James Gosling, 1998-02-28&quot;</p><h3 id="我们可以用n-bits来表示什么呢" tabindex="-1">我们可以用N bits来表示什么呢？ <a class="header-anchor" href="#我们可以用n-bits来表示什么呢" aria-label="Permalink to “我们可以用N bits来表示什么呢？”">​</a></h3><ul><li>Unsigned integers: 0 to $2^N -1$</li><li>Signed integers(2进制补码): $-2^{N-1}$ to $2^{N-1} -1$</li></ul><h3 id="但是其他的数字呢" tabindex="-1">但是其他的数字呢？ <a class="header-anchor" href="#但是其他的数字呢" aria-label="Permalink to “但是其他的数字呢？”">​</a></h3><ol><li>比如说很大的数字 31,556,926,00010 ($3.155692610 \\times 10^{10}$)</li><li>或者很小的数字 0.000000000052917710m ($5.2917710 \\times 10^{-11}$)</li><li>还有 <strong>小数以及分数</strong> 呢？</li></ol><p>我们接下来将介绍分数（小数）的表示方法，这也会对第1，2点的解决有所帮助</p><h3 id="分数的表示" tabindex="-1">分数的表示 <a class="header-anchor" href="#分数的表示" aria-label="Permalink to “分数的表示”">​</a></h3><p>&quot;2进制小数点&quot;像十进制一样都是数字整数部分和小数部分的分割线 以6-bit表示为例 <span class="bc">xx.yyyy</span></p><p>$10.1010_2 = 1 \\times 2^1 + 1 \\times 2^{-1} +1 \\times 2^{-3} =2.625_{10}$ 如果我们假设这是一个“定点二进制小数点”，那么这6比特位可以代表从0到3.9375（接近4）这样的范围</p><div class="info custom-block"><p class="custom-block-title custom-block-title-default">INFO</p><p>显然我们觉得这并不是一个很好的实践</p></div><h2 id="浮点表示法" tabindex="-1">浮点表示法 <a class="header-anchor" href="#浮点表示法" aria-label="Permalink to “浮点表示法”">​</a></h2><h3 id="科学计数法" tabindex="-1">科学计数法 <a class="header-anchor" href="#科学计数法" aria-label="Permalink to “科学计数法”">​</a></h3><p>目前为止，在我们的例子中，我们用的都是定点表示，但是我们真正想要的是将小数点 <strong>float</strong> （浮动）起来。但是为什么呢？</p><ul><li>浮点数可以极大地提升储存数据的效率（储存相同数据占用的比特位更少），因此也就增加了数据表示的的精准度</li></ul><details class="details custom-block"><summary>Details</summary><p>比如，我们将一个十进制0.1640625储存进计算机（2进制表示） 标准(normal)格式：$+1.xxxx...x_{two} * 2^{yyy...yy_{two}}$ <img src="'+t+'" alt="fp32"> 32位浮点数最小（绝对值）可以到$1.2 \\times 10^{-38}$，最大可以到$3.4 \\times 10^{38}$</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>注意，在normal格式下，有效位小数点前默认的<code>&quot;1&quot;</code>是省略不存储的</p></div></details><ul><li>如果结果太大呢？（绝对值超出了可表示范围$3.4 \\times 10^{38}$ ）</li></ul><p>则会导致<code>overflow</code>！</p><div class="warning custom-block"><p class="custom-block-title custom-block-title-default">WARNING</p><p>Overflow!-&gt;指数大于8比特位可表示的范围</p></div><ul><li>如果结果太小呢？绝对值小于可表示范围$1.2 \\times 10^{-38}$ ）</li></ul><p>则会导致<code>underflow </code>!</p><div class="warning custom-block"><p class="custom-block-title custom-block-title-default">WARNING</p><p>Underflow!-&gt;负向指数超过8比特位可表示的范围</p></div><p><img src="'+i+`" alt="outflow"> 一定要搞清楚<code>overflow</code>和<code>underflow</code>的差别，负向的超限也叫overflow而只有趋向于0才叫underflow</p><p>所以,总结下来，1位的符号位，1表示负数，0表示正数；</p><p>对于有效位(Significand)：</p><ul><li>对于normalized numers，1会默认不储存</li><li>换成double可以有52位储存，会更精确</li><li>通常有效位会大于0小于1（normalized）</li></ul><div class="info custom-block"><p class="custom-block-title custom-block-title-default">INFO</p><p>但是，产生了一个问题：对于数字0，他并没有前导的1，所以我们约定将所有指数位(exponent)置为0表示0，但是问题又出现了，不同的sign位还会导致“两个零”问题的出现</p></div><p>于是，我们引入了另一个IEEE754中很重要的概念<code>偏移指数（biased exponent）</code></p><p>设计者们希望浮点数可以在没有专门的浮点数硬件的条件下仍然可以使用，想用大的指数代表大的数字，指数越大数值则越大，我们需要一个像<code>里程表式</code>的指数位，从最小达到最大可以表示整体数值的最小到最大，显然2进制补码等等都完成不了这个任务，我们在这里使用<code>移码</code>的概念，从000...000到1111...111就是表示一个线性增加的过程，那么我们就需要一个偏移量来让它可以表示负值。在ieee754中，我们规定了一个负向的偏移量-127。</p><p>至于为什么是负向127，首先是ieee754规定的对于n位，偏移量为$2^{n-1}-1$，其次，感性地来理解，我们希望指数的正负部分是对称的，在增长到10000000的时候实际值恰好从负数变成0</p><p>所以，最终我们的公式(32-bit)就是 $$(-1)^S \\times (1+Significand) \\times 2^{(Exponent-127)}$$</p><h2 id="特殊数字" tabindex="-1">特殊数字 <a class="header-anchor" href="#特殊数字" aria-label="Permalink to “特殊数字”">​</a></h2><h3 id="无穷-的表示方法" tabindex="-1">“无穷”的表示方法 <a class="header-anchor" href="#无穷-的表示方法" aria-label="Permalink to ““无穷”的表示方法”">​</a></h3><p>首先，表示“无穷”是很有必要的，比如我们在程序的某个部分要维护一个max</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0" dir="ltr"><code><span class="line highlighted"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> my_max</span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;">MIN;</span><span style="color:#7F848E;font-style:italic;">  //MIN代表无穷小</span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> i</span><span style="color:#C678DD;">=</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;i</span><span style="color:#C678DD;">&lt;</span><span style="color:#ABB2BF;">n;i</span><span style="color:#C678DD;">++</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //a是一个数组，n是元素个数</span></span>
<span class="line"><span style="color:#ABB2BF;">    my_max</span><span style="color:#C678DD;">=</span><span style="color:#61AFEF;">max</span><span style="color:#ABB2BF;">(my_max,</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">[i]);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre></div><p>如果我们可以用<code>MIN</code>来代表无穷小，那么<code>a[0]</code>首先一定会被保存到<code>my_max</code>因为无穷小肯定比<code>a[0]</code>要小，这样就可以很自然的向后遍历。 同时，X/0&gt;Y可能也是个合法的比较。所以在浮点数里表示无穷还是很有必要的。</p><h3 id="ieee754表示无穷" tabindex="-1">IEEE754表示无穷 <a class="header-anchor" href="#ieee754表示无穷" aria-label="Permalink to “IEEE754表示无穷”">​</a></h3><ul><li>如果无穷是合法的，这个结果也理应是合法的，我们称其为<span class="highlight">Not a Number</span></li><li>表示为指数全1，有效位不全0</li></ul><h4 id="为什么是有意义的" tabindex="-1">为什么是有意义的？ <a class="header-anchor" href="#为什么是有意义的" aria-label="Permalink to “为什么是有意义的？”">​</a></h4><p>鉴于有效位有23位，我们可以有$2^{23}-1$种NaN，如果这都是没意义的，那么闲的我们对空间的利用效率太低了！</p><ul><li>我们希望NaN可以对debug有所帮助</li><li>比如，NaN是具有传播性的，operate(NaN,x)=NaN，NaN和任何数做运算结果都是NaN，所以我们如果得到一个NaN的结果说明整个计算过程中必然有一步产生了不合理的NaN结果（但不会error）</li><li>我们还可以用NaN的非0有效位去表示产生了那种错误，比如对0/0进行一种encode放到有效位里，把“对读书开根号”进行一种encode放入有效位里，这样我们后续通过decode有效位的错误信息编码就可以知晓前面运算发生了哪种错误</li></ul><h3 id="非规格化数字的表示-denorms" tabindex="-1">非规格化数字的表示(Denorms) <a class="header-anchor" href="#非规格化数字的表示-denorms" aria-label="Permalink to “非规格化数字的表示(Denorms)”">​</a></h3><div class="danger custom-block"><p class="custom-block-title">我们还有一个问题</p><p>在0和规格浮点数(normalized)之间有一个很大的缝隙gap！</p></div><ul><li>可表示的最小规格数为：a=$1.000.._2 * 2^{-126}$=$2^{-126}$</li><li>可表示的第二小的规格数为：n=$1.000...01_2 * 2^{-126}=(1+0.00...1_2) * 2^{-126}=(1+2^{-23}) * 2^{-126}=2^{-126}+2^{-149}$</li><li>a-0=$2^{-126}$</li><li>b-a=$2^{-149}$</li><li>0和可表示最小规格数的距离是下一个距离的$2^{23}$倍！这真的是一个很大的gap!</li></ul><p><span class="highlight">造成这样的罪魁祸首其实是隐式省略的1！</span></p><p>那我们如何解决这个问题呢？</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>我们发现我们还没有用指数全为1，有效位不全0的情况，我们可以用在这里</p></div><p>所以denormalized number就是取消了前导1，在数值上默认指数值为-126（但其实实际储存是全0）</p><ul><li>这样的，最小的非规格数就是$2^{-149} \\times 2^{-23}$</li><li>第二小的非规格数就是$2^{-148} \\times 2^{-23}$</li><li>在一段范围内“步幅”都是$2^{-149} \\times 2^{-23}$,当有效位增长到111...11时，再“迈一步”就会进一位到指数位，指数位+1，步幅变成$2^{-125} \\times 2^{-23}$了，然后有效位继续从0增长到全一，然后步幅再一次翻倍。总体来说，在一个阶段内，共走了$2^{23}-1$步，步幅从最开始$2^{-149} \\times 2^{-23}$，每走$2^{23}-1$步就乘2，那么可以预想到终有一步，步幅会大于1，这就以为这从这里开始就有整数不能用float表示</li><li>那么什么时候步幅为1呢？显然是指数值是$2^{23}$的时候这样和有效位的$2^{-23}$乘起来才会是1 <img src="`+n+'" alt="stride=1"> 此时有效位全1，再迈一步，进位指数+1，有效位全0，步幅变为2，结果变为16777216，再迈一步此时步幅是2，结果变为16777218，如图： <img src="'+c+'" alt="stride=2"> 我们“神奇”地发现16777217“消失”了，其实是float到这里精度已经很小了，储存不了166777217了，换成double的话保持精确的范围还会更大一点</li></ul><p>最后总结一下： <img src="'+p+'" alt="consulution"></p><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" target="_blank" rel="noreferrer">ieee754模拟器</a></p>',52)])])}const g=l(r,[["render",d]]);export{_ as __pageData,g as default};
