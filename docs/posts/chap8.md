---
title: " CSAPP Chap8"
date: 2025-11-26 21:40:35
---

## 异常
是异常控制流的一种形式，一部分由硬件实现，一部分由软件实现，所以由硬件实现的部分和具体的系统有关。

异常是控制流中的突变。处理器状态发生一个重要的变化时将引发异常。有些是系统内部的有些是系统外部的。

### 异常处理
系统为每种异常都分配了一个唯一的异常号，系统启动时可以通过一个寄存器——异常表基址寄存器找到异常表，再根据异常号作为偏移脚标找到对应的异常处理程序的地址，执行间接调用。

与普通的函数过程调用相似，但是也有基点不同：
+ 普通过程调用将返回地址压入栈中，而异常可能是返回到当前指令或者下一条指令
+ 在异常中处理器会把更多的寄存器压入栈中
+ 如果控制流从用户程序转移到内核，寄存器都会被压入内核栈而不是用户栈
+ 异常处理程序运行在内核态，可以访问所有系统资源

### 异常的分类
1. 中断：
   中断是异步发生的，是处理器外部io设备的信号的结果。总是返回到下一条指令。
2. 陷阱(trap)和系统调用
   陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户态和内核态之间提供了一个像过程一样的接口——系统调用(可以通过一个钩子函数完成)。

   可以通过一条"syscall n"指令来向内核请求服务，和普通函数不同的是，system call运行在内核态。

   同样是返回到下一条指令

3. 故障
    由错误情况引起。处理器将控制流转移给故障处理程序，成功修复就返回当前指令重新执行，否则进入abort例程，终止程序。
    典型是缺页异常。

4. 终止
   不可修复

c程序用syscall可以直接进程任何系统及调用，但是实际上标准c库提供了方便的包装函数，我们将系统调用以及相关联的包装函数都称为系统级函数。

## 进程控制

### 获取进程id
```c
#include<sys/types.h>
#include<unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```
返回一个类型为`pid_t`的整数值，在linux的`types.h`里·被定义为`int`

### 创建和终止进程
从程序员的角度，我们可以认为进程总是处于以下三种状态：
+ 运行。要么执行，要么就绪状态
+ 停止。进程被挂起，不会被调度。当收到SIGSTOP,SIGTSTP,SIGTTIN信号时，进程停止，并且保持停止直到收到SIGCONT信号，才再次开始运行
+ 终止。进程永远的停止了。三种原因：1) 收到一个信号，该信号的默认行为是终止进程。2)从主程序返回 3)调用exit函数

```c
void exit(int status);
```
`exit`通过设置一个status退出状态来终止进程，return 一个数也可以

```c
pid_t fork(void);
```
新创立的子进程与父进程大多相同但是也有不同。子进程得到父进程一个虚拟空间的副本，也包括打开的文件描述符

### 回收子进程
已终止的子进程只有被父进程回收之后才消失，不然就是僵尸进程。

如果父进程终止了，内核会安排init进程(pid=1)做他子进程的养父，而父进程终止却还未来得及回收子进程，init则会代替回收。

函数waitpid的默认情况(option=0)是wait挂起调用进程的执行，直到它的等待集合的任意一个子进程终止。waitpid返回导致waitpid返回的已终止子进程的pid,该已终止子进程被回收。

1. 判定等待集合中的成员
   + 参数pid>0,则等待集合就是一个单独的进程，即id=pid
   + 参数pid=-1，等待集合为父进程的所有子进程

2. 修改默认行为
   通过option参数
3. 检查已回收的子进程的退出状态
    通过status来实现
4. 错误条件

wait函数是waitpid的简单版本，等价于`waitpid(-1,&status,0)`

### 让进程休眠

```c
unsigned int sleep(unsigned int secs);
```
如果请求的时间量已经到了则返回0.否则返回还剩下的休眠秒数。注意，第二种情况是可能发生的，因为sleep函数可能被一个信号`中断`而过早返回


```c
int pause(void);
```
pause函数让进程休眠，直到收到一个信号

### 利用fork和execve运行程序

## 信号

一种更高层次的软件层次的异常。一个信号就是一条小消息，他通知进程系统中发生了一个某种类型的事件

### 信号术语
+ 发送信号：内核通过更新目的进程的上下文中的某个状态，来表示发送一个信号给目的进程。有如下两种原因：
  1. 内核检测到一个系统事件，比如除零错误或者子进程终止
  2. 一个进程调用了kill函数显式地发给目的进程。
+ 接收信号：当目的进程被内核强迫以某种方式对信号做出反应时，他就接收了信号。进程可以忽略这个信号也可以通过执行一个`信号处理程序`地用户层函数来捕获这个信号。

一个发出但是还没被接收的信号叫做`待处理信号`。**一种类型最多只有一个待处理信号**，因为信号没有排队的概念，多余的待处理信号只会被抛弃。一个进程也可以通过`blocked`向量选择性地阻塞接收某种信号，被阻塞的信号仍可以被发送但是不会被接收。

内核为每个进程维护`pending`位向量和`blocked`位向量，只要传送了一个k类型的信号，内核就会设置pending中的第k位，而接收之后就会被清除

### 发送信号

#### 进程组
每个进程只属于一个进程组，用一个进程组号来标识

```c
pid_t getpgrp(void);
```
默认一个子进程继承父亲的进程组，也可以通过`setpgid`来修改

```c
int setpgid(pid_t pid,pid_t pgid);
```
若此`pid`为0，则代表被修改进程组的进程为本进程，`pgid`为0则代表用本进程的进程号修改进程组号，则
```c
setpgid(0,0);
```
就可以被理解为将本进程加入一个进程组号为本进程进程号的进程组

#### 使用`bin/kill`程序发送信号
很多人可能对`bin/kill`有语义上的误解，`bin/kill`事实上可以发送任何信号，不只是终止进程的信号
```bash
/bin/kill -9 15213  //表示给15213号进程发9信号
/bin/kill -9 -15213  //表示给15213号进程组的所有进程发送9信号
```

#### 从键盘发送信号

#### 用`alarm`函数发送信号
```c
unsigned int alarm(unsigned int secs);
```
alarm函数安排内核在secs秒后发送一个`SIGALRM`信号给调用进程








