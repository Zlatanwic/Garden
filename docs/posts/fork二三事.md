---
title: fork二三事
date: 2025-11-26
excerpt: This is my first post on this new VitePress blog.
---


# fork 二三事

笔者在自己学习fork的时候产生了好几个疑惑，经过笔者的冥思苦想和资料查阅，把我觉得初学者比较难理解的点总结讲解一下。

## unix v6pp如何实现的父子进程fork的返回值不同
在学校的操作系统讲到fork之前我就已经学习csapp的异常控制流而会使用fork进行基本的编程了(调用unix api)，知道所谓的“调用一次，返回两次”，但是却没有深入研究过具体是如何实现的。于是我和同学交流过后，我去看了mit 的xv6的实现，发现其实是在fork的系统调用里把risc-v的a0寄存器改掉了，虽然返回语句都是`return pid`，但是从汇编的角度，其实返回不同的值。到这里我以为我理解了一切，但是当我去自己看我们unxi v6pp的具体实现的时候就懵了，他的实现是和xv6的实现不同的，或者说他的实现是更贴近unix v6原作者汤普森的实现逻辑的，就是swtch的使用，虽然说看起来没有xv6好懂，但是本质是一样的，都是要从汇编的视角理解，到这里我真的难以想象汤普森是如何想出这种实现方式的，实在是天才且伟大。那么接下来就来具体讲解一下。

让我们编写用户态的程序，调用fork函数时，我们进行了一次系统调用，`trap`之后调用了`Sys_Fork`，然后在内部调用了`processManager`类的`Fork函数`，在这个函数里就到了我们的核心`newProc`函数，正如我们之前所了解的，newProc会将很大一部分父进程的东西复制给子进程，得到了和父进程基本一样的进程图象，然后聪明的你看到以下这段代码突然顿悟：哦，原来fork是通过newProc不同的返回值实现的
```cpp
	if ( this->NewProc() )	/* 子进程返回1，父进程返回0 */
	{
		/* 子进程fork()系统调用返回0 */
		u.u_ar0[User::EAX] = 0;
		u.u_cstime = 0;
		u.u_stime = 0;
		u.u_cutime = 0;
		u.u_utime = 0;
	}
	else
	{
		/* 父进程进程fork()系统调用返回子进程PID */
		u.u_ar0[User::EAX] = child->p_pid;
	}
```
然后你会怀着激动的心去看newProc的内部，期待着可以证实你的猜想，但是却惊讶的发现————`newProc`函数“看起来”是恒返回0的，那么就意味着刚才这段代码永远执行else分支，但，这对吗？这明显不对！但是为什么...这就需要我们去看具体的栈帧了。

细心的读者可能会想到，在父进程为子进程创建好进程图象时，父进程和子进程的栈帧栈顶都是newProc栈帧，父进程的相对好理解，显然初始状态是父进程上台，如果newProc正常返回就会返回0，然后Fork就会返回pid，符合我们的设想。而子进程稍复杂一点，因为初始时刻，子进程是没上台的，处于就绪状态，但是他总有一刻要上台，而上台靠的是`swtch`函数，可以理解成swtch的返回就是子进程newProc的返回，因为撤销newProc栈帧时取的都是newProc栈帧保存的old eip，就同样返回到子进程调用newProc的下一条指令，而我们知道x86体系结构函数返回值是存在EAX寄存器的，所以子进程swtch返回1就以为着将子进程的核心栈的eax寄存器的值改为1，从汇编的角度理解，newProc返回时核心栈eax的值，父进程是0，子进程是1，就表现出newProc父进程返回0，子进程返回1，根据这个判断条件就实现了processManager::Fork的父进程返回pid，子进程返回0。

```cpp
	/* 
	 * 被fork出的进程在上台之前会在被调度上台时返回1，
	 * 并同时返回到NewProc()执行的地址
	 */
	return 1;
```
到这里读者可能对fork如何实现父进程返回pid，子进程返回0有了一个更好的了解，那我们再看一下从c程序角度，笔者到这里又出现了理解的问题

## 父子进程的并发流

假设我们在用户态写了这样一段代码
```cpp
if(pid=fork()){
    printf("Parent process\n");
}
else{
    printf("Child process\n");
}
```
如果你在一个系统多次运行这个程序你会得到什么结果呢，你觉得是谁先打印，父进程还是子进程，还是不确定。其实csapp明确告诉过我们就是不确定的，但是我那时候还不知道为什么，在系统了解方钰老师讲解的unix v6pp新进程的创建全过程之后，我对他有了一个更深入的了解。

按照我们正常的对程序的理解，他默认是顺序执行的，即我们可以理解为，在fork之前，其实我们执行的是“父进程”，因为是父进程创建的子进程，也就是fork的一套流程默认是父进程先占用cpu来执行，比如父进程按流程正常从newProc一步步返回到例行调度阶段
::: tip
注意，因为父进程没有入睡，所以trap的`set_Pri`并没有对父进程的优先级产生什么实质性的影响
:::
到这里，父进程是可能被其他进程抢占下台的，是否会被抢占主要就是取决于`RunRun`标志位是否被设置，于是就有三种情况：
1. 父进程在cpu上执行了太长时间，在整数秒被重算优先级，发现p_pri增加（优先级降低）
2. 父进程由于某些原因入睡，重新上台到trap末尾被重算优先级，p_pri增加
3. 父进程未返回用户态之前，系统恰好产生中断，进程处理中断唤醒了优先级更高的进程

如果发生这三件事，父进程就有可能被子进程抢占，如果没发生，那么父进程就会顺利先于子进程返回用户态，去执行用户态程序。

现在我们再来看子进程，子进程一旦创建就是就绪状态且p_pri=0，因为和父进程有相同的栈帧，所以返回的步骤是一样的，也需要在trap重算优先级，这样的话p_pri从0增加到100以上，RunRun标志位是必然会被设置的，就意味着子进程的例行调度必然会下台，下台之后，如果父进程发生了刚才说的那三件事，那么现在父子进程就都在就绪状态，看processManager能选到谁，而这个选进程的机制是从上次上台的进程开始在proc表里循环选择，所以当进程数较少且程序结构清晰的时候你可能发现很多时候都是父进程先被选中上台，然后先返回，但是一旦程序变得复杂，那么就完全无法确定了。

::: tip
同时要注意的是，有些系统可能会用特殊的机制保证父进程先还是子进程先，但是unxi v6原版以及我们的unxi v6pp是没有这种机制的。
:::

到这里看似是比较清晰的，但是我们一定要有`并发流`的概念，比如父进程先返回了pid，我们就根据代码直接执行相应的分支了，完全不会管另外一个分支，此时子进程可能甚至还没上台还在就绪状态，只有父进程因为某些原因再下台才轮到子进程执行并返回0，才去执行另一个分支。不要以为都返回了，才会执行，父子进程是完全并发的，，共享一段代码，但是用户栈核心栈等等在两个物理地址


